#summary Lists stuff we need to do, along with who's doing it.

= To Do =
  * Re-implement the scheduler. Round robin with priority is what we decided upon.
  * Functions we need to implement:

|| function || who's doing it || arguments || description ||
|| open || corey || {{{const char *path, int  oflag, mode_t mode}}} || It  should be as simple as it seems ||
|| read || corey || {{{int fd, void *buf, size_t nbytes}}} || You can use struct uios, and make sure you understand it. You also can check out VOP_READ. ||
|| write || corey || {{{int fd, const void `*`buf, size_t nbytes}}} || Involves I/O to userland. You can use struct uios  again. Please check out  VOP_WRITE. ||
|| lseek || corey|| {{{int fd, off_t offset, int whence}}} || Can we always perform an lseek? For example, can we perform lseek() beyond the end of a file? Please use VOP_TRYSEEK. ||
|| close || corey || {{{int fd}}} || It may be interesting because of the refcounting  issue (think about garbage collection)! ||
|| dup2 || corey || {{{int oldfd, int newfd}}} || If newfd is already opened, close it. Upon successful completion, both file descriptors refer to the same file table object and share all properties of the object. ||
|| getpid || sean || || This will be the simplest function you write in this semester. A pid, or process ID, is a unique number identifying a process. The implementation of getpid() is not challenging, but pid allocation and reclamation are the important concepts that must be implemented. Your system should not crash because over the lifetime of its execution the system has used up all the pids. Design your pid  system; implement all the tasks associated with pid  maintenance, and only then implement getpid(). ||
|| fork || sean || || fork()  is the mechanism necessary for creating new processes. It should make a copy of the invoking process and make sure that the parent and child processes each observe the correct return value (that is, 0 for the child and the newly created pid  for the parent). You need to carefully design fork() and consider it together with what execv()  does to make sure that each system call is performing the correct functionality. ||
|| execv || sean || {{{const char *path, const *char argv[]}}} || execv(), although "only" a system call, is really the heart of this assignment. It is responsible for taking newly created processes and make theme execute something useful (i.e., something different than what the parent is executing). Essentially, it must replace the existing address space with a brand new one for the new executable (created by calling as_create in the current dumbvm  system) and then run it. While this is similar to starting a process straight out of the kernel (as runprogram() does), it's not quite that simple. Remember that this call is coming out of userspace, into the kernel, and then returning back to userspace. You must manage the memory that travels across these boundaries very carefully. (Also, notice that runprogram() doesn't take an argument vector -- but this must of course be handled correctly in execv()). ||
|| waitpid || || {{{pid_t wpid, int `*`status, int options}}} || Although it may seem simple at first, waitpid() requires a fair bit of design. Read the specification carefully to understand the semantics, and consider these semantics from the ground up in your design. You may also wish to consult the UNIX man page, though bear in mind that you are not required to implement all the things UNIX waitpid() supports -- nor is the UNIX parent/child model of waiting the only valid or viable possibility. ||
|| `_`exit || || || The implementation of `_`exit()  is closely connected to the implementation of waitpid(). They are essentially two components of the same mechanism. The code for `_`exit() will be relatively simpler and the code for waitpid() relatively more complicated. The basic rule is to understand what waitpid() is doing, so your implementation of  `_`exit() can work with it. ||
|| kill_curthread || || || Please implement kill_curthread() in a simple manner. It is worth noting essentially nothing about the current thread's user space state can be trusted if it has suffered a fatal exception -- it must be taken off the processor in a judicious manner, but without returning execution to the user level. ||